<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module eipmi_session</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module eipmi_session</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
   A server providing session management for IPMI over lan channels.

<p><b>Behaviours:</b> <a href="gen_server.html"><tt>gen_server</tt></a>.</p>

<h2><a name="description">Description</a></h2><p>
   A server providing session management for IPMI over lan channels. The
   session will be established as soon as the server gets started. An
   established session will be closed when the server terminates. The user
   can close the session using <a href="#stop-1"><code>stop/1</code></a>.</p>
  
   <p>Synchronous requests can be issued over this session at any given time using
   <a href="#rpc-3"><code>rpc/3</code></a> or <a href="#rpc-4"><code>rpc/4</code></a>. When the session is not yet established
   requests will be queued and issued as soon as the far end (BMC) is ready.
   Request timeouts can be configured on state machine startup using the
   <code>timeout</code> property of the <code>Options</code> field.</p>
  
   <p>A session may be shared between mutliple processes. While the requests of   
one process will be synchronous and thus ordered, requests from different   
processes will not block each other. However, it should be mentioned that   
a BMC is allowed to discard packets with a sequence number difference of 8.   
Since the session does not (yet) provide any kind of flow control it is the   
responsibility of the rpc-ing processes to care for the total number of   
concurrent RPCs or to live with error/timeout returns.</p>
  
   <p>The server will handle the low level RMCP and IPMI protocol regarding   
encoding and decoding of messages, as well as correct packet   
acknowledgement, sequence number handling and session opening/closing.   
Packet loss is not handled during session setup.</p>
  
   <p>A session will use the modules <a href="eipmi_request.html"><code>eipmi_request</code></a> and
   <a href="eipmi_response.html"><code>eipmi_response</code></a> to encode and decode requests/responses. Therefore,   
there's no need to edit the session but extending these modules when   
support for new requests/responses is added.</p>
  
   Currently all incoming packets are considered to be IPMI responses
   and outbound sequence numbers are not tracked/checked.
  
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-property">property()</a></h3>
<p><tt>property() = <a href="eipmi.html#type-option">eipmi:option()</a> | {auth_type, none | pwd | md5 | md2} | {auth_types, [none | pwd | md5 | md2]} | {challenge, binary()} | {completion, atom()} | {inbound_seq_nr, non_neg_integer()} | {login_status, [anonymous | null | non_null]} | {outbound_seq_nr, non_neg_integer()} | {rq_seq_nr, 0..64} | {session_id, non_neg_integer()}</tt></p>


<h3 class="typedecl"><a name="type-property_name">property_name()</a></h3>
<p><tt>property_name() = <a href="eipmi.html#type-option_name">eipmi:option_name()</a> | auth_type | auth_types | challenge | completion | inbound_seq_nr | login_status | outbound_seq_nr | rq_seq_nr | session_id</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#rpc-3">rpc/3</a></td><td>
  Basically the same as <a href="#rpc-4"><code>rpc/4</code></a>, but the number of allowed retransmits
  is taken from the <code>eipmi</code> application configuration.</td></tr>
<tr><td valign="top"><a href="#rpc-4">rpc/4</a></td><td>
  Send a synchronous IPMI RPC over this session.</td></tr>
<tr><td valign="top"><a href="#start_link-3">start_link/3</a></td><td>
  Starts a session server which in turn will occupy a free UDP socket.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="rpc-3">rpc/3</a></h3>
<div class="spec">
<p><tt>rpc(Pid::pid(), Request::<a href="eipmi.html#type-request">eipmi:request()</a>, Properties::<a href="proplists.html#type-proplist">proplists:proplist()</a>) -&gt; {ok, <a href="proplists.html#type-proplist">proplists:proplist()</a>} | {error, term()}</tt><br></p>
</div><p>
  Basically the same as <a href="#rpc-4"><code>rpc/4</code></a>, but the number of allowed retransmits
  is taken from the <code>eipmi</code> application configuration. If not configured the
  default number of allowed retransmits is <code>2</code>.</p>
<p><b>See also:</b> <a href="#rpc-4">rpc/4</a>.</p>

<h3 class="function"><a name="rpc-4">rpc/4</a></h3>
<div class="spec">
<p><tt>rpc(Pid::pid(), Request::<a href="eipmi.html#type-request">eipmi:request()</a>, Properties::<a href="proplists.html#type-proplist">proplists:proplist()</a>, Retransmits::non_neg_integer()) -&gt; {ok, <a href="proplists.html#type-proplist">proplists:proplist()</a>} | {error, term()}</tt><br></p>
</div><p>
  Send a synchronous IPMI RPC over this session. If the session is not yet
  established the request will be queued. The last arguments specifies the
  number of allowed retransmits. Since requests get sent over UDP packet
  delivery may be unreliable and requests could get lost.</p>

<h3 class="function"><a name="start_link-3">start_link/3</a></h3>
<div class="spec">
<p><tt>start_link(Session::<a href="eipmi.html#type-session">eipmi:session()</a>, IPAddress::<a href="inet.html#type-ip_address">inet:ip_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>, Options::[<a href="#type-property">property()</a>]) -&gt; {ok, pid()} | {error, term()}</tt><br></p>
</div><p>
  Starts a session server which in turn will occupy a free UDP socket. The
  provided IP address and network port will be used to send requests. This
  means that the target for this session server is static and configured on
  startup. This will also setup a session by sending the necessary IPMI
  protocol messages. All requests received before the session is activated will
  be queued and sent as soon as the session is established.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Apr 15 2013, 15:55:39.</i></p>
</body>
</html>
